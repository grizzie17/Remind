/*---------------------------------------------------------------------+\|																		||				Copyright 1986 .. 1997 Grizzly Software					||					a division of Bear Consulting Group					||						  All Rights Reserved							||																		||	This software-file/document, in whole or in part, including			||	the structures and the procedures described herein, may not			||	be provided or otherwise made available without prior written		||	authorization.  In case of authorized or unauthorized				||	publication or duplication, copyright is claimed.					||																		|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\||	remparse.cpp  --  class to parse reminder text strings||	Purpose:|	Author and Date:	J.Griswold			16-Sep-1995|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\||	Revision History:|	03-Apr-1997			J.Griswold		Add parsing of PREF strings, this allows the preferences to be		stored in identical format	12-Mar-1997			J.Griswold		Add asserts in parsing the message text.	16-Sep-1995			J.Griswold		Initial Revision|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\|																		||	Include Files														||																		|\+---------------------------------------------------------------------*///#include "stdafx.h"		// must be first include for MFC#include <string.h>#include <ctype.h>#include <limits.h>#include "bcrtti.h"#include "token.h"#include "tokencnv.h"#include "tparse.h"#include "tparsmsg.h"#include "xpassert.h"#include "remparse.h"#include "remdoc.h"#include "dateownr.h"#include "dateinc.h"#include "datepars.h"#include "datejul.h"#include "datedmy.h"#include "datewmy.h"#include "datewday.h"#include "datemoon.h"#include "datepas.h"#include "dkeyword.h"#include "holiday.h"#include "rstring.h"#include "julian.h"/*---------------------------------------------------------------------+\|																		||	Local defines / constants											||																		|\+---------------------------------------------------------------------*///#define INHERITED	BaseClass#define	LIT_LPAREN	('(')#define LIT_RPAREN	(')')#define LIT_LBRACE	('{')#define LIT_RBRACE	('}')#define LIT_BSLASH	('\\')// directive (command)#define DIRECT_None			0#define	DIRECT_Category		1#define DIRECT_Style		2#define DIRECT_Include		3#define DIRECT_Reference	4#define DIRECT_Default		-1#define	SUBDIRECT_End		1#define	PBcommand			PB_Offset( nCommand )#define PBsubcommand		PB_Offset( nSubCommand )#define PBbefore			PB_Offset( nBefore )#define PBafter				PB_Offset( nAfter )#define	PBpriority			PB_Offset( nPriority )#define PBfontsize			PB_Offset( nFontSize )#define PBfontface			PB_Offset( mFontFace )#define PBfontcolor			PB_Offset( nFontColor )#define PBfontname			PB_Offset( sFontName )#define PBoverride			PB_Offset( mOverride )#define PBparentstyle		PB_Offset( sParentStyle )#define PBparentcategory	PB_Offset( sParentCategory )#define	PBnamestyle			PB_Offset( sNameStyle )#define	PBnamecategory		PB_Offset( sNameCategory )#define	PBstring			PB_Offset( string )#define PB_Offset( x )  	TPA_Offset( TBlockData, x )/*---------------------------------------------------------------------+\|																		||	Local Type Definitions												||																		|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\|																		||	Private Global Variables											||																		|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\|																		||	Public Global Variables												||																		|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\|																		||	External Variables													||																		|\+---------------------------------------------------------------------*//*=====================================================================+\||																		|||	 Parse Table														|||																		|\+=====================================================================*//*---------------------------------------------------------------------+\ *  NAME:	checkColor - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	dd-mmm-1996\+---------------------------------------------------------------------*/static Severity		checkColor		(		TParseManager	*pManager,		TParseState		*pTrans,		char			*pToken,		int				lenToken,		long			argument		){	TBlockDataPtr	p;	int				j;	Char			symbol[40];		UNREFERENCED_PARAMETER( pTrans );	UNREFERENCED_PARAMETER( argument );		if ( sizeof(symbol)-1 < lenToken )		lenToken = sizeof(symbol) - 1;	::strncpy( symbol, pToken, lenToken );	symbol[lenToken] = '\0';		if ( 0 < (j = get_color( symbol )) )	{		p = (TBlockDataPtr)pManager->pBlock;		p->nFontColor = j - 1;		p->mOverride |= STYLE_OverrideColor;		return TPA_S_SUCCESS;	}	else	{		return TPA_E_ERROR;	}}/*---------------------------------------------------------------------+\ *  NAME:	checkWeekday - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	26-Mar-1997\+---------------------------------------------------------------------*/static Severity		checkWeekday		(		TParseManager	*pManager,		TParseState		*pTrans,		char			*pToken,		int				lenToken,		long			argument		){	TBlockDataPtr	p;	int				j;	Char			symbol[40];		UNREFERENCED_PARAMETER( pTrans );	UNREFERENCED_PARAMETER( argument );		if ( sizeof(symbol)-1 < lenToken )		lenToken = sizeof(symbol) - 1;	::strncpy( symbol, pToken, lenToken );	symbol[lenToken] = '\0';		if ( 0 < (j = dkeyword_findWeekday( symbol )) )	{		p = (TBlockDataPtr)pManager->pBlock;		// insert assignment in pBlock		//p->nFontColor = j - 1;		//p->mOverride |= STYLE_OverrideColor;		return TPA_S_SUCCESS;	}	else	{		return TPA_E_ERROR;	}}/*---------------------------------------------------------------------+\ *  NAME:	checkMonth - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	26-Mar-1997\+---------------------------------------------------------------------*/static Severity		checkMonth		(		TParseManager	*pManager,		TParseState		*pTrans,		char			*pToken,		int				lenToken,		long			argument		){	TBlockDataPtr	p;	int				j;	Char			symbol[40];		UNREFERENCED_PARAMETER( pTrans );	UNREFERENCED_PARAMETER( argument );		if ( sizeof(symbol)-1 < lenToken )		lenToken = sizeof(symbol) - 1;	::strncpy( symbol, pToken, lenToken );	symbol[lenToken] = '\0';		p = (TBlockDataPtr)pManager->pBlock;	if ( 0 < (j = dkeyword_findMonth( symbol )) )	{		// insert assignment in pBlock		//p->nFontColor = j - 1;		//p->mOverride |= STYLE_OverrideColor;		return TPA_S_SUCCESS;	}	else if ( 0 < (j = dkeyword_findEvenOdd( symbol )) )	{		// insert assignment in pBlock		//p->nFontColor = j - 1;		//p->mOverride |= STYLE_OverrideColor;		return TPA_S_SUCCESS;	}	else	{		return TPA_E_ERROR;	}}/*=====================================================================+\||																		|||	 Parse Table														|||																		|\+=====================================================================*/#if 0#pragma mark ________Parse_Table________stateEOS(){#endif//// end-of-string//STATE_	stateEOS	TRANS1_	TPA_C( '!' )	TRANS_	TPA_C( ';' )	TRANS_	TPA_EOSEND_STATE_#if 0}directives(){#endif//// block directives//static TParseTList blockDirectiveList[]={	"category",		DIRECT_Category,	"styles",		DIRECT_Style,	"categories",	DIRECT_Category,	0};STATE_	stateBlockDirective	TRANS1_	TPA_TList( blockDirectiveList ),TPA_EXIT,	TPA_Assign( PBcommand )END_STATE_STATE_	stateEndBlockDirective	TRANS1_	TPA_T( "end" ),				TPA_NEXT,	TPA_Set( SUBDIRECT_End, PBsubcommand )NEXT_STATE_	TRANS_	TPA_Sub( stateBlockDirective )END_STATE_//// line directives//STATE_	stateLineDirective	TRANS1_	TPA_T( "include" ),			TPA_NEXT	TRANS_	TPA_T( "reference" ),		TPA_NEXTNEXT_STATE_	TRANS_	TPA_FILESPEC,				TPA_EXIT,	TPA_Assign( PBstring )	TRANS_	TPA_IQUOTE,					TPA_EXIT,	TPA_Assign( PBstring )END_STATE_STATE_	stateDirective	TRANS1_	TPA_C( '#' )NEXT_STATE_	TRANS_	TPA_Sub( stateBlockDirective )	TRANS_	TPA_Sub( stateEndBlockDirective )	TRANS_	TPA_Sub( stateLineDirective )NEXT_STATE_	TRANS_	TPA_Sub( stateEOS )END_STATE_#if 0}styles(){#endif////	font face style//static TParseTList listFaceStyle[]={	"bold",			FONTFACE_Bold,	"italic",		FONTFACE_Italic,	"underlined",	FONTFACE_Underline,	"outlined",		FONTFACE_Outline,	"shadowed",		FONTFACE_Shadow,	"condensed",	FONTFACE_Condense,	"extended",		FONTFACE_Extend,	0};STATE_	s_faceStyle	TRANS1_	TPA_TList( listFaceStyle ),TPA_EXIT, TPA_Or( 0, PBfontface )	TRANS_	TPA_T( "normal" ),	TPA_EXIT,	TPA_Set( 0, PBfontface )	TRANS_	TPA_T( "plain" ),	TPA_EXIT,	TPA_Set( 0, PBfontface )END_STATE_////	a set of face styles enclosed in parens//STATE_	localFaceSet	TRANS1_	TPA_Sub( s_faceStyle )NEXT_STATE_	TRANS_	TPA_C( ',' ),	localFaceSet	TRANS_	TPA_LAMBDA,		TPA_EXITEND_STATE_STATE_	stateFaceSet	TRANS1_	TPA_C( '(' )NEXT_STATE_	TRANS_	TPA_Sub( localFaceSet )NEXT_STATE_	TRANS_	TPA_C( ')' )END_STATE_STATE_	stateFaceKwd	TRANS1_	TPA_T( "face" )NEXT_STATE_	TRANS_	TPA_C( '=' )NEXT_STATE_	TRANS_	TPA_Sub( stateFaceSet )	TRANS_	TPA_Sub( s_faceStyle )END_STATE_////	text color//STATE_	stateTextColor	TRANS1_	TPA_SYMBOL, TPA_EXIT,	TPA_NoAction,	checkColorEND_STATE_STATE_	stateTextColorKeyword	TRANS1_	TPA_T("color")NEXT_STATE_	TRANS_	TPA_C( '=' )NEXT_STATE_	TRANS_	TPA_Sub( stateTextColor ), TPA_EXITEND_STATE_////	font name//STATE_	s_fontName	TRANS1_	TPA_T( "font" )NEXT_STATE_	TRANS_	TPA_C( '=' )NEXT_STATE_	TRANS_	TPA_SYMBOL,	TPA_EXIT,	TPA_Assign( PBfontname )	TRANS_	TPA_IQUOTE,	TPA_EXIT,	TPA_Assign( PBfontname )END_STATE_////	font size//STATE_	s_textSize	TRANS1_	TPA_T( "size" )NEXT_STATE_	TRANS_	TPA_C( '=' )NEXT_STATE_	TRANS_	TPA_UNSIGNED,	TPA_EXIT,	TPA_Assign( PBfontsize )END_STATE_////	parent style//STATE_	s_parentStyle	TRANS1_	TPA_T( "style" )NEXT_STATE_	TRANS_	TPA_C( '=' )NEXT_STATE_	TRANS_	TPA_SYMBOL,	TPA_EXIT,	TPA_Assign( PBparentstyle )	TRANS_	TPA_IQUOTE,	TPA_EXIT,	TPA_Assign( PBparentstyle )END_STATE_////	parse any list of style stuff//STATE_	stateStyleComponent	TRANS1_	TPA_Sub( s_parentStyle ),TPA_EXIT	TRANS_	TPA_Sub( s_textSize ),	TPA_EXIT,	TPA_Or( STYLE_OverrideSize, PBoverride )	TRANS_	TPA_Sub( s_faceStyle ),	TPA_EXIT,	TPA_Or( STYLE_OverrideFace, PBoverride )	TRANS_	TPA_Sub( stateFaceKwd ),	TPA_EXIT,	TPA_Or( STYLE_OverrideFace, PBoverride )	TRANS_	TPA_Sub( s_fontName ),	TPA_EXIT,	TPA_Or( STYLE_OverrideFont, PBoverride )	TRANS_	TPA_Sub( stateTextColorKeyword ),										TPA_EXIT,	TPA_Or( STYLE_OverrideColor, PBoverride )	TRANS_	TPA_Sub( stateTextColor ),	TPA_EXIT,	TPA_Or( STYLE_OverrideColor, PBoverride )END_STATE_STATE_	stateLocalStyle	TRANS1_	TPA_Sub( stateStyleComponent )NEXT_STATE_	TRANS_	TPA_C( '%' ),	stateLocalStyle	TRANS_	TPA_C( ',' ),	stateLocalStyle	TRANS_	TPA_LAMBDA,		TPA_EXITEND_STATE_STATE_	stateParseStyles	TRANS1_	TPA_C( '%' ),	stateLocalStyleEND_STATE_////	parse style as contained in preference data//STATE_	statePrefStyle	TRANS1_	TPA_Sub( stateLocalStyle )NEXT_STATE_	TRANS_	TPA_Sub( stateEOS )END_STATE_////	parse named style//STATE_	stateNamedStyle	TRANS1_	TPA_SYMBOL,		TPA_NEXT,	TPA_Assign( PBnamestyle )	TRANS_	TPA_IQUOTE,		TPA_NEXT,	TPA_Assign( PBnamestyle )NEXT_STATE_	TRANS_	TPA_Sub( stateParseStyles )	TRANS_	TPA_LAMBDA,		TPA_NEXTNEXT_STATE_	TRANS_	TPA_Sub( stateEOS )END_STATE_////	parse style list//STATE_	stateStyleList	TRANS1_	TPA_Sub( stateNamedStyle )	TRANS_	TPA_Sub( stateDirective )END_STATE_////	parse message style info \{style-stuff}//STATE_	stateMessageStyle	TRANS1_	TPA_C( '{' ),	TPA_NEXTNEXT_STATE_	TRANS_	TPA_Sub( stateLocalStyle )	TRANS_	TPA_LAMBDANEXT_STATE_	TRANS_	TPA_C( '}' ),	TPA_EXITEND_STATE_#if 0}category_items(){#endif////	before [ : after ]//STATE_	s_pendingBefore	TRANS1_	TPA_UNSIGNED,	TPA_NEXT,	TPA_Assign( PBbefore )END_STATE_STATE_	s_pendingRange	TRANS1_	TPA_UNSIGNED,	TPA_NEXT,	TPA_Assign( PBbefore )NEXT_STATE_	TRANS_	TPA_C( ':' ),	TPA_NEXTNEXT_STATE_	TRANS_	TPA_UNSIGNED,	TPA_EXIT,	TPA_Assign( PBafter )END_STATE_STATE_	s_pending	TRANS1_	TPA_Sub( s_pendingRange ),	TPA_EXIT,	TPA_Or( CATEGORY_OverridePending, PBoverride )	TRANS_	TPA_Sub( s_pendingBefore ),	TPA_EXIT,	TPA_Or( CATEGORY_OverrideRangeBefore, PBoverride )END_STATE_STATE_	s_pendingKeyword	TRANS1_	TPA_T( "pending" )NEXT_STATE_	TRANS_	TPA_C( '=' ),	s_pendingEND_STATE_////	priority//STATE_	s_priority	TRANS1_	TPA_T( "priority" )NEXT_STATE_	TRANS_	TPA_C( '=' )NEXT_STATE_	TRANS_	TPA_UNSIGNED,	TPA_EXIT,	TPA_Assign( PBpriority )END_STATE_////	parent category//STATE_	s_parentCategory	TRANS1_	TPA_T( "category" )NEXT_STATE_	TRANS_	TPA_C( '=' )NEXT_STATE_	TRANS_	TPA_SYMBOL,	TPA_EXIT,	TPA_Assign( PBparentcategory )	TRANS_	TPA_IQUOTE,	TPA_EXIT,	TPA_Assign( PBparentcategory )END_STATE_STATE_	stateCategoryComponent	TRANS1_	TPA_Sub( s_parentCategory )	TRANS_	TPA_Sub( s_pendingKeyword ),TPA_EXIT	TRANS_	TPA_Sub( s_pending ),	TPA_EXIT	TRANS_	TPA_Sub( s_priority ),	TPA_EXIT,	TPA_Or( CATEGORY_OverridePriority, PBoverride )	TRANS_	TPA_Sub( stateStyleComponent )END_STATE_STATE_	stateLocalCategories	TRANS1_	TPA_Sub( stateCategoryComponent )NEXT_STATE_	TRANS_	TPA_C( '%' ),	stateLocalCategories	TRANS_	TPA_C( ',' ),	stateLocalCategories	TRANS_	TPA_LAMBDA,		TPA_EXITEND_STATE_STATE_	stateParseCategories	TRANS1_	TPA_C( '%' ),	stateLocalCategoriesEND_STATE_////	parse named category//STATE_	stateNamedCategory	TRANS1_	TPA_SYMBOL,		TPA_NEXT,	TPA_Assign( PBnamecategory )	TRANS_	TPA_IQUOTE,		TPA_NEXT,	TPA_Assign( PBnamecategory )NEXT_STATE_	TRANS_	TPA_Sub( stateParseCategories )	TRANS_	TPA_LAMBDA,		TPA_NEXTNEXT_STATE_	TRANS_	TPA_Sub( stateEOS )END_STATE_////	parse category list//STATE_	stateCategoryList	TRANS1_	TPA_Sub( stateNamedCategory )	TRANS_	TPA_Sub( stateDirective )END_STATE_#if 0}message_prefix(){#endif////	handle the pending and style stuff//STATE_	s_msgPfx	TRANS1_	TPA_Sub( stateCategoryComponent )NEXT_STATE_	TRANS_	TPA_C( '%' ),	s_msgPfx	TRANS_	TPA_C( ',' ),	s_msgPfx	TRANS_	TPA_LAMBDA,		TPA_EXITEND_STATE_STATE_	stateMessagePrefix	TRANS1_	TPA_C( '%' ),	s_msgPfxEND_STATE_#if 0}date_parse(){#endifstatic TParseTList listOddEven[]={	"odd",	1,	"even",	2,	0};STATE_	s_evenOddPfx	TRANS1_	TPA_TList( listOddEven ),TPA_NEXTNEXT_STATE_	TRANS_	TPA_C( ':' )END_STATE_//	parse [even|odd :] weekday-nameSTATE_	stateWeekday	TRANS1_	TPA_Sub( s_evenOddPfx )	TRANS_	TPA_LAMBDA,		TPA_NEXTNEXT_STATE_	TRANS_	TPA_SYMBOL, TPA_EXIT,	TPA_NoAction,	checkWeekdayEND_STATE_//	parse monthstatic TParseTList listMonthCycle[]={	"bimonthly",	2,	"quarterly",	3,	"semiannual",	6,	"annual",		12,	0};STATE_	stateMonth	TRANS1_	TPA_SYMBOL, TPA_EXIT,	TPA_NoAction,	checkMonth	TRANS_	TPA_TList( listOddEven ),TPA_EXIT	TRANS_	TPA_TList( listMonthCycle ),TPA_NEXTNEXT_STATE_	TRANS_	TPA_C( LIT_LPAREN )NEXT_STATE_	TRANS_	TPA_UNSIGNEDNEXT_STATE_	TRANS_	TPA_C( LIT_RPAREN )END_STATE_#if 0}#endif/*=====================================================================+\||																		|||	 Code																|||																		|\+=====================================================================*/#if 0#pragma mark ____class____#endif/*---------------------------------------------------------------------+\ *  NAME:	 RemindParse - constructor *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	16-Sep-1995\+---------------------------------------------------------------------*/RemindParse::RemindParse		(		void		){	initRemindParse();}/*---------------------------------------------------------------------+\ *  NAME:	 RemindParse - constructor *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	16-Sep-1995\+---------------------------------------------------------------------*/RemindParse::RemindParse		(		RemindDocument*	pDoc		){	initRemindParse();	vpDoc = pDoc;}/*---------------------------------------------------------------------+\ *  NAME:	~RemindParse - destructor *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	16-Sep-1995\+---------------------------------------------------------------------*/RemindParse::~RemindParse		(		void		){	if ( vpActiveStyle )		vpActiveStyle->release();	if ( vpDefaultStyle )		vpDefaultStyle->release();//	if ( vpRunningStyle )//		vpRunningStyle->release();		if ( vpCategoryDefault )		vpCategoryDefault->release();	if ( vpCategoryRunning )		vpCategoryRunning->release();	if ( vpCategoryActive )		vpCategoryActive->release();		if ( vpStyleMgr )		vpStyleMgr->release();	if ( vpCategoryMgr )		vpCategoryMgr->release();}/*---------------------------------------------------------------------+\ *  NAME:	 initRemindParse - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	16-Sep-1995\+---------------------------------------------------------------------*/void	RemindParse::initRemindParse		(		void		){	vpDoc = NULL;	veState = STATE_Normal;	vpStyleMgr = NULL;	vpCategoryMgr = NULL;		vpCurr = NULL;	vpErrors = NULL;	vpMessages = NULL;	vpActiveStyle = NULL;	vpDefaultStyle = NULL;//	vpRunningStyle = NULL;	vnActiveStyleID = 0;			// what actually gets assigned to the message	vnDefaultStyleID = 0;//	vnRunningStyleID = 0;		vpCategoryDefault = NULL;	vnCategoryDefaultID = 0;	vpCategoryRunning = NULL;	vnCategoryRunningID = 0;	vpCategoryActive = NULL;	vnCategoryActiveID = 0;}/*=====================================================================+\||	 public member functions											|\+=====================================================================*/#if 0#pragma mark ____public____#endif/*---------------------------------------------------------------------+\ *  NAME:	initialize - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	16-Sep-1995\+---------------------------------------------------------------------*/Bool	RemindParse::initialize		(		void		){	Bool	result = NO;		do	{		vpStyleMgr = ZStyleManager::getStyleManager();		XP_Assert( vpStyleMgr );		if ( NULL == vpStyleMgr )			break;		vpStyleMgr->addRef();				vpCategoryMgr = ZCategoryManager::getCategoryManager();		XP_Assert( vpCategoryMgr );		if ( NULL == vpStyleMgr )			break;		vpCategoryMgr->addRef();		vpDefaultStyle = (RStylePtr)vpStyleMgr->getDefaultStyle();		XP_Assert( vpDefaultStyle );		vpDefaultStyle->addRef();		vnDefaultStyleID = vpDefaultStyle->getIdent();				vpActiveStyle = vpDefaultStyle;		vpActiveStyle->addRef();		vnActiveStyleID = vnDefaultStyleID;		//		vpRunningStyle = vpDefaultStyle;//		vpRunningStyle->addRef();//		vnRunningStyleID = vnDefaultStyleID;				vpCategoryDefault = (RCategoryPtr)vpCategoryMgr->getDefaultCategory();		XP_Assert( vpCategoryDefault );		vpCategoryDefault->addRef();		vnCategoryDefaultID = vpCategoryDefault->getIdent();				vnCategoryRunningID = vnCategoryDefaultID;		vpCategoryRunning = vpCategoryDefault;		vpCategoryRunning->addRef();				vnCategoryActiveID = vnCategoryDefaultID;		vpCategoryActive = vpCategoryDefault;		vpCategoryActive->addRef();		//		vDefaultPending.nBefore = 5;//		vDefaultPending.nAfter = 0;				vnUntitled = vpCategoryMgr->getNamedItemCount();		result = YES;			} while ( 0 );		return result;}/*---------------------------------------------------------------------+\ *  NAME:	 parseString - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	16-Sep-1995\+---------------------------------------------------------------------*/Bool	RemindParse::parseString		(		CharPtr	sLine		){	Bool			result = NO;	CharPtr			s;		switch ( veState )	{	case STATE_Normal:		s = sLine;		s += ::tok_blank( s );		if ( '#' == *s )			result = parseDirective( s );		else			result = parseNormal( s );		break;		case STATE_StyleList:	// # stuff			result = parseStyleList( sLine );		break;		case STATE_CategoryList:			result = parseCategoryList( sLine );		break;			default:		veState = STATE_Undefined;		break;	}				return result;}/*---------------------------------------------------------------------+\ *  NAME:	 getMessages - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	16-Sep-1995\+---------------------------------------------------------------------*/RMessagePtr		RemindParse::getMessages		(		void		){	return vpMessages;}/*---------------------------------------------------------------------+\ *  NAME:	 getErrors - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	25-Oct-1995\+---------------------------------------------------------------------*/RErrorPtr		RemindParse::getErrors		(		void		){	return vpErrors;}/*---------------------------------------------------------------------+\ *  NAME:	 parsePrefStyle - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	18-Mar-1997\+---------------------------------------------------------------------*/Bool	RemindParse::parsePrefStyle		(		RStyleInfoPtr	pInfo,		CharPtr			sPref		){	Severity		sts;	TBlockData		tb;	TParseManager	tpaMgr;		::memset( &tb, 0, sizeof(tb) );	tparse_initialize( &tpaMgr );	sts = tparse_parseLine( &tpaMgr, statePrefStyle, &tb, sPref );	if ( ISFAIL( sts ) )		return NO;		if ( *(sPref + tpaMgr.numCharsParsed) )		// did not fully parse		return NO;		if ( 0 == tb.nCommand )	{		pInfo->font.size = (Byte)tb.nFontSize;		pInfo->font.face = (Byte)tb.mFontFace;		pInfo->nColor = (Byte)tb.nFontColor;		if ( tb.sFontName[0] )		{			XPFontPtr	pFontServer;						pFontServer = XPFont::getFontServer();			pInfo->font.ident = pFontServer->getFontIDFromName( tb.sFontName);		}		else		{			pInfo->font.ident = 0;		}		return YES;	}	else	{		return NO;	}}/*=====================================================================+\||	 protected member functions											|\+=====================================================================*/#if 0#pragma mark ____protected____#endif/*---------------------------------------------------------------------+\ *  NAME:	 parseNormal - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	16-Sep-1995\+---------------------------------------------------------------------*/Bool	RemindParse::parseNormal		(		CharPtr		string		){	Bool			result = NO;	int				n;	CharPtr			s;	Bool			bHoliday;	Long			nSize;	RMessagePtr		pText;	TBlockData		tBlock;	MParse			parseBlock;	MIncParse		parseIncBlock;	DateRootPtr		pDate;	DateOwnerPtr	pOwnerDate;	RStylePtr		pStyle;	int				nStyleRunCount;	TStyleRunRecord	styleRunList[16];	char			sOutString[256];		s = string;		::memset( &parseBlock, 0, sizeof( parseBlock ) );		//	parse the old style "pending" and "style" definitions	//parseBlock.pending = vDefaultPending;	//vpRunningStyle->getData( &parseBlock.style );	//vpRunningStyle->addRef();	//vpActiveStyle->release();	//vpActiveStyle = vpRunningStyle;	//vnActiveStyleID = vnRunningStyleID;		vpCategoryRunning->addRef();	vpCategoryActive->release();	vpCategoryActive = vpCategoryRunning;	vnCategoryActiveID = vnCategoryRunningID;	n = parseMessagePrefix( &tBlock, s );	if ( 0 < n )	{		if ( activateCategoryAndStyle( &tBlock ) )		{			if ( DIRECT_Default == tBlock.nCommand )			{				vpCategoryActive->addRef();				if ( vpCategoryRunning )					vpCategoryRunning->release();				vpCategoryRunning = vpCategoryActive;				vnCategoryRunningID = vnCategoryActiveID;				return YES;			}		}	}		s += n;	s += ::tok_blank( s );	n = parseDate( &pDate, s );	if ( n > 0 )	{		s += n;				//	handle the increment format after the date		do		{			s += ::tok_blank( s );			n = parseIncrement( &parseIncBlock, s );			if ( 0 == n )				break;			s += n;			if ( pDate )			{				pOwnerDate = new DateIncrement( parseIncBlock.nCondition,												parseIncBlock.nFormat,												parseIncBlock.nIncrement );				if ( pOwnerDate )				{					pOwnerDate->setDate( pDate );					pDate = pOwnerDate;				}				else				{					n = 0;				}			}		} while ( n > 0 );				//	NEEDS_WORK: add parsing the new format "style" definitions				bHoliday = parseHoliday( s );		if ( bHoliday )			Holiday::addDate( pDate );				//	what ever is left over is the message		//	NEEDS_WORK: add parsing of the message to handle imbedded formatting		if ( vnActiveStyleID )			pStyle = vpActiveStyle;		else			pStyle = vpCategoryActive->getStylePtr();		nSize = parseMessageText( &nStyleRunCount, styleRunList, sOutString, s, pStyle );		//nSize = ::strlen( s );		//pText = NEW RMessage( s, nSize );		pText = new RMessage( sOutString, nSize );		XP_Assert( pText );		if ( pText )		{			//pText->setPending( parseBlock.pending.nBefore, parseBlock.pending.nAfter );			pText->setStyleID( vnActiveStyleID );			if ( 0 < nStyleRunCount )				pText->loadStyleRuns( styleRunList, nStyleRunCount );			pText->setCategoryID( vnCategoryActiveID );			pText->setDate( pDate );			pText->calcDisplaySize( PIXEL_MAX, NULL );			if ( NULL == vpMessages )			{				vpMessages = vpCurr = pText;			}			else			{				vpCurr->setNext( pText );				vpCurr = pText;			}			result = YES;		}	}	else	{		parseError( s );		result = NO;	}		return result;}/*---------------------------------------------------------------------+\ *  NAME:	 parseDirective - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	15-Sep-1995\+---------------------------------------------------------------------*/int		RemindParse::parseDirective		(		CharPtr		string		){	TBlockData		parseBlock;	int				sts;	TParseManager	tpaMgr;		::memset( &parseBlock, 0, sizeof( parseBlock ) );		::tparse_initialize( &tpaMgr );	sts = ::tparse_parseLine( &tpaMgr, stateDirective, &parseBlock, string );	if ( ISFAIL( sts ) )	{		parseError( string );		return 0;	}		if ( 0 != parseBlock.nSubCommand )	{		parseError( string );		return 0;	}		switch ( parseBlock.nCommand )	{	case DIRECT_Category:		veState = STATE_CategoryList;		break;	case DIRECT_Style:		veState = STATE_StyleList;		break;	default:		parseError( string );		break;	}		return 1;}/*---------------------------------------------------------------------+\ *  NAME:	 parseStyleList - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	17-Sep-1995\+---------------------------------------------------------------------*/Bool	RemindParse::parseStyleList		(		CharPtr	string		){	Bool			result = YES;	Severity		sts;	CharPtr			stringBegin = string;	TBlockData		tb;	TParseManager	tpaMgr;		::memset( &tb, 0, sizeof(tb) );	tparse_initialize( &tpaMgr );	sts = tparse_parseLine( &tpaMgr, stateStyleList, &tb, string );	if ( ISFAIL( sts ) )	{		parseError( string );		return NO;	}		if ( 0 == tb.nCommand )	// style	{		RStylePtr	pNewStyle;				pNewStyle = buildStyle( &tb, vpDefaultStyle );		if ( NULL == pNewStyle )			return NO;	}	else // directive	{		if ( 0 == tb.nSubCommand )		{			parseError( string );			return NO;		}				if ( DIRECT_Style == tb.nCommand )		{			veState = STATE_Normal;			return YES;		}		else		{			parseError( string );			return NO;		}	}		return result;}/*---------------------------------------------------------------------+\ *  NAME:	 parseCategoryList - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	17-Sep-1995\+---------------------------------------------------------------------*/Bool	RemindParse::parseCategoryList		(		CharPtr	string		){	Bool			result = YES;	CharPtr			stringBegin = string;	TBlockData		tb;	Severity		sts;	TParseManager	tpaMgr;		::memset( &tb, 0, sizeof(tb) );	tparse_initialize( &tpaMgr );	sts = tparse_parseLine( &tpaMgr, stateCategoryList, &tb, string );	if ( ISFAIL( sts ) )	{		parseError( string );		return NO;	}		if ( 0 == tb.nCommand )	// category	{		RCategoryPtr	pNewCategory;				pNewCategory = buildCategory( &tb, vpCategoryDefault );		if ( pNewCategory )			return YES;	}	else // directive	{		if ( 0 == tb.nSubCommand )		{			parseError( string );			return NO;		}				if ( DIRECT_Category == tb.nCommand )		{			veState = STATE_Normal;			return YES;		}		else		{			parseError( string );			return NO;		}	}		return result;}/*---------------------------------------------------------------------+\ *  NAME:	 parseMessagePrefix - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	30-Apr-1995\+---------------------------------------------------------------------*/int		RemindParse::parseMessagePrefix		(		TBlockDataPtr	pParseBlock,		CharPtr			string		){	CharPtr			stringBegin = string;	Severity		sts;	TParseManager	tpaMgr;		::memset( pParseBlock, 0, sizeof(TBlockData) );	//tb.nBefore = pMParse->pending.nBefore;	//tb.nAfter = pMParse->pending.nAfter;	tparse_initialize( &tpaMgr );	sts = tparse_parseLine( &tpaMgr, stateMessagePrefix, pParseBlock, string );	if ( ISSUCCESS( sts ) )	{		string += tpaMgr.numCharsParsed;				//pMParse->pending.nBefore = (short)tb.nBefore;		//pMParse->pending.nAfter = (short)tb.nAfter;		//pMParse->mOverride = tb.mOverride;		//if ( tb.sFontName[0] )		//{		//	XPFontPtr		pFontServer;		//			//	pFontServer = XPFont::getFontServer();		//	pMParse->style.font.ident = pFontServer->getFontIDFromName( tb.sFontName );		//}		//pMParse->style.font.size = (Byte)tb.nFontSize;		//pMParse->style.font.face = (Byte)tb.mFontFace;		//pMParse->style.nColor = (Byte)tb.nFontColor;		//::strcpy( pMParse->sParentStyle, tb.sParentStyle );			if ( stringBegin < string )		{			if ( '\0' == *string  ||  '!' == *string )				pParseBlock->nCommand = DIRECT_Default;			//	pMParse->dateType = DATE_Default;		}	}		return string - stringBegin;}/*---------------------------------------------------------------------+\ *  NAME:	 parseDate - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	06-May-1995\+---------------------------------------------------------------------*/int		RemindParse::parseDate		(		DateRootPtr	*hDate,		CharPtr		string		){	int			len;	int			nDay;	int			nWeekDay;	int			nWeekNum;	int			nMonth;	int			nCycle;	int			nYear;	int			nAnniv;	int			nIdent;	char		*start;	DateEnum	nType = DATE_Unknown;		start = string;	len = 0;	*hDate = NULL;	do /* sequence */	{		len = parse_weekday( &nWeekNum, &nWeekDay, string );		if ( len )		{			nType = DATE_Weekday;			break;		}				len = parse_ddmmmyyyy( &nDay, &nMonth, &nCycle, &nYear, &nAnniv, string );		if ( len )		{			nType = DATE_DMY;			break;		}		len = parse_nnwwwmmmyyyy( &nWeekNum, &nWeekDay, &nMonth, &nCycle, &nYear, &nAnniv, string );		if ( len )		{			nType = DATE_WMY;			break;		}		len = parse_mdy(  &nDay, &nMonth, &nCycle, &nYear, &nAnniv, string );		if ( len )		{			nType = DATE_DMY;			break;		}		len = parse_mmmddyyyy(  &nDay, &nMonth, &nCycle, &nYear, &nAnniv, string );		if ( len )		{			nType = DATE_DMY;			break;		}		len = parse_moonPhase( &nIdent, string );		if ( len )		{			nType = DATE_Moon;			break;		}				len = parse_kwdday( &nIdent, string );		if ( len )		{			if ( nIdent <= 4 )				nType = DATE_Paschal;			else				nType = DATE_Keyword;			break;		}	} while ( 0 ); /* end sequence */		if ( DATE_Unknown != nType )	{		switch ( nType )		{		case DATE_DMY:						if ( nDay > 0  &&  nMonth > 0  &&  nYear > 0  					&&  nCycle == 0  &&  nAnniv == 0 )			{				int		n;				Long	nRepeat = 0;				Long	nMaxRepeat = 0;				Long	value = julianDate_numberFromGregorian( nDay, nMonth, nYear );								string += len;				string += ::tok_blank( string );				if ( '&' == *string )				{					++string;					string += ::tok_blank( string );					n = ::tokenCnv_decimal( &nRepeat, string );					if ( n > 0 )					{						string += n;						len = string - start;						string += ::tok_blank( string );						if ( ':' == *string )						{							++string;							string += ::tok_blank( string );							n = ::tokenCnv_decimal( &nMaxRepeat, string );							if ( n > 0 )							{								string += n;								len = string - start;							}						}					}				}				*hDate = new DateJulian( value, nRepeat, nMaxRepeat );			}			else			{				*hDate = new DateDMY( nDay, nMonth, nCycle, nYear, nAnniv );			}			break;				case DATE_WMY:					*hDate = new DateWMY( nWeekNum, nWeekDay, nMonth, nCycle, nYear, nAnniv );			break;				case DATE_Weekday:					*hDate = new DateWeekday( nWeekDay, nWeekNum );			break;				case DATE_Moon:					*hDate = new DateMoon( nIdent );			break;				case DATE_Paschal:					*hDate = new DatePaschal( nIdent );			break;					default:			len = 0;			break;		}	}		return len;}/*---------------------------------------------------------------------+\ *  NAME:	 parseIncrement - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	18-May-1995\+---------------------------------------------------------------------*/int		RemindParse::parseIncrement		(		MIncParsePtr	pMParse,		CharPtr			string		){	CharPtr	stringBegin = string;	long	tok;	int		n;	int		sign;	int		state;	char	symbol[32];	pMParse->nCondition = 0;	pMParse->nFormat = 0;	pMParse->nIncrement = 0;	string += ::tok_blank( string );	if ( '?' == *string )	{		CharPtr	stringSave = string;		++string;		string += ::tok_blank( string );		n = ::tokenCnv_symbol( symbol, string, sizeof( symbol ) );		if ( n )		{			string += n;			string += ::tok_blank( string );			tok = dkeyword_findWeekday( symbol );			if ( tok )			{				pMParse->nCondition = tok;			}			else			{				tok = dkeyword_findSpecialDay( symbol );				if ( tok )					pMParse->nCondition = tok;				else					string = stringSave;	// failure			}		}		else		{			string = stringSave;	// failure		}	}		string += ::tok_blank( string );	state = 1;	while ( state )	{		switch ( state )		{		case 0:		case 1:					switch ( *string )			{			case '-':				sign = (-1);				++string;				pMParse->nFormat = INC_WKD_ON_B;				state = 2;				break;			case '+':				sign = 1;				++string;				pMParse->nFormat = INC_WKD_ON_A;				state = 3;				break;			case '~':				++string;				pMParse->nFormat = INC_WKD_NEAREST;				state = 4;				break;			default:				state = 98;		/* error */				break;			}			break;				case 2:					if ( '-' == *string )		/* must be weekday */			{				++string;				state = 4;				pMParse->nFormat = INC_WKD_BEFORE;			}			else			{				state = 4;			}			break;				case 3:					if ( '+' == *string )			{				++string;				state = 4;				pMParse->nFormat = INC_WKD_AFTER;			}			else				state = 4;			break;				case 4:					string += ::tok_blank( string );			n = tokenCnv_symbol( symbol, string, sizeof( symbol ) );			if ( n )			{				string += n;				tok = dkeyword_findWeekday( symbol );				if ( tok )				{					pMParse->nIncrement = tok;					state = 99;				}				else				{					tok = dkeyword_findSpecialDay( symbol );					if ( tok )					{						pMParse->nIncrement = tok;						state = 99;					}					else						state = 98;				}			}			else			{				state = 5;			}			break;				case 5:					string += ::tok_blank( string );			n = ::tokenCnv_decimal( &tok, string );			if ( n )			{				string += n;				pMParse->nIncrement = tok * sign;				pMParse->nFormat = INC_VALUE;				state = 99;			}			else				state = 98;			break;					case 98:		/* error condition */					string = stringBegin;			pMParse->nFormat = 0;			state = 0;			break;				case 99:					state = 0;			break;				default:					state = 98;			break;		}	}		return string - stringBegin;}/*---------------------------------------------------------------------+\ *  NAME:	 parseHoliday - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	28-May-1995\+---------------------------------------------------------------------*/Bool	RemindParse::parseHoliday		(		CharPtr	string		){	Bool	result = NO;	int		n;	char	symbol[32];		do // sequence	{		string += tok_blank( string );		if ( '(' != *string )			break;				++string;		string += tok_blank( string );		n = tokenCnv_symbol( symbol, string, sizeof( symbol ) );		if ( 0 == n )			break;					if ( -3 != dkeyword_findSpecialDay( symbol ) )	// keyword "holiday"			break;				string += n;		string += tok_blank( string );		if ( ')' != *string )			break;				result = YES;	} while ( 0 ); // end sequence		return result;}/*---------------------------------------------------------------------+\ *  NAME:	parseMessageText - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	15-Apr-1996\+---------------------------------------------------------------------*/int		RemindParse::parseMessageText		(		IntPtr		pStyleCount,		// OUT:	number of entries in pStyleRun		TStyleRunRecordPtr pStyleRun,	// OUT:	style run information		CharPtr		sOutString,			// OUT:	resulting character string		CharPtr 	sInString,			// IN:	source data		RStylePtr	pStyle				// IN:	primary style		){	CharPtr			s;	CharPtr			sRunBegin;	CharPtr			sOutBegin;	int				n;	int				i;	int				j;	char			sToken[40];	Severity		sts;	TParseManager	tpaMgr;	TBlockData		tb;	ZStyleID		nCurrentID = 0;	RStylePtr		pNewStyle = NULL;	TStyleRunRecordPtr	pRunRecBegin = pStyleRun;		*sOutString = '\0';	sOutBegin = sOutString;	s = sInString;	sRunBegin = s;		while ( *s )	{		XP_AssertMsg( (s - sRunBegin < long(UCHAR_MAX)),					"style run is too long to fit" );		if ( LIT_BSLASH == *s  &&  LIT_LBRACE == *(s+1) )		{			::memset( &tb, 0, sizeof(tb) );			tparse_initialize( &tpaMgr );			sts = tparse_parseLine( &tpaMgr, stateMessageStyle, &tb, s+1 );			if ( ISSUCCESS( sts ) )			{				if ( sRunBegin < s )				{					pStyleRun->nCharCount = s - sRunBegin;					pStyleRun->nStyleID = nCurrentID;					pStyleRun->pHandler = NULL;					++pStyleRun;				}				s += tpaMgr.numCharsParsed + 1;	// (+1) for back-slash				sRunBegin = s;								if ( 2 == tpaMgr.numCharsParsed )				{					nCurrentID = 0;				}				else				{					pNewStyle = buildStyle( &tb, pStyle );					if ( pNewStyle )					{						nCurrentID = pNewStyle->getIdent();					}				}			}			else			{				*sOutString++ = *s++;			}		}		else if ( 'f' == tolower( *s )  &&  '$' == *(s+1) )		{			n = tokenCnv_symbolDollar( sToken, s, sizeof(sToken) );			if ( n )			{				//s += n;				i = ::tok_blank( s+n );				j = get_function( sToken );				if ( j  &&  LIT_LPAREN == *(s+n+i) )				{					if ( sRunBegin < s )					{						pStyleRun->nCharCount = s - sRunBegin;						pStyleRun->nStyleID = nCurrentID;						pStyleRun->pHandler = NULL;						++pStyleRun;					}					sRunBegin = sOutString;										::strcpy( sOutString, gListFunc[j-1] );					sOutString += ::strlen( gListFunc[j-1] );					*sOutString++ = LIT_LPAREN;					s += n + i + 1;					s += ::tok_blank( s );			    	switch ( j )			    	{			    	case 1:	// f$years			    	case 3:	// f$days			    		n = ::tok_number( s );			    		::memcpy( sOutString, s, n );			    		sOutString += n;			    		s += n;			    		break;			    	case 2:	// f$julian			    	case 4:	// f$moon_time			    	case 5:	// f$hilite			    		break;			    	default:			    		break;			    	}			    	s += ::tok_blank( s );			    	if ( LIT_RPAREN == *s )			    		++s;			    	*sOutString++ = LIT_RPAREN;			    						pStyleRun->nCharCount = sOutString - sRunBegin;					pStyleRun->nStyleID = nCurrentID;					pStyleRun->pHandler = (RStyleRunHandler*)0xFFFFFFFFL;					++pStyleRun;										sRunBegin = s;				}				else				{					::strcpy( sOutString, sToken );					sOutString += n;					s += n;				}			}		}		else		{			*sOutString++ = *s++;		}	}		if ( pRunRecBegin < pStyleRun )	{		pStyleRun->nCharCount = s - sRunBegin;		pStyleRun->nStyleID = nCurrentID;		pStyleRun->pHandler = NULL;		++pStyleRun;	}	*pStyleCount = pStyleRun - pRunRecBegin;	*sOutString = '\0';		return sOutString - sOutBegin;}/*---------------------------------------------------------------------+\ *  NAME:	parseError - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	29-Oct-1995\+---------------------------------------------------------------------*/void	RemindParse::parseError		(		CharPtr	s		){	RErrorPtr	pError;		pError = new RError( s, ::strlen( s ) );	if ( pError )	{		pError->setStyleID( vnDefaultStyleID );		if ( NULL == vpErrors )			vpErrors = pError;		else			vpErrors->appendLink( pError );	}}/*---------------------------------------------------------------------+\ *  NAME:	activateCategoryAndStyle - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	10-Apr-1996\+---------------------------------------------------------------------*/Bool	RemindParse::activateCategoryAndStyle		(		TBlockDataPtr	pParseBlock		){	Bool			result = NO;	RCategoryPtr	pParentCategory = NULL;	RCategoryPtr	pNewCategory = NULL;	RStylePtr		pParentStyle = NULL;	RStylePtr		pNewStyle = NULL;		//	.. resolve parent-category	//	if named category specified	//		use named category as parent-category	//	else	//		use running-category as parent-category	//	if ( pParseBlock->sParentCategory[0] )	{		ZCategoryID	idParent;				idParent = vpCategoryMgr->findNamedCategory( pParseBlock->sParentCategory );		if ( idParent )			pParentCategory					= DYNAMIC_CAST( RCategoryPtr,									vpCategoryMgr->getCategoryFromID( idParent ) );		else			pParentCategory = vpCategoryRunning;	}	else	{		pParentCategory = vpCategoryRunning;	}		//	.. resolve named style	//	if named style specified	//		set parent-style to named style	//	else	//		set parent-style to null	//	if ( pParseBlock->sParentStyle[0] )	{		ZStyleID	idParent;				idParent = vpStyleMgr->findNamedStyle( pParseBlock->sParentStyle );		if ( idParent )			pParentStyle = DYNAMIC_CAST( RStylePtr, vpStyleMgr->getStyleFromID( idParent ) );		else			pParentStyle = NULL;	}	else	{		pParentStyle = NULL;	}	//	if style-override items were specified	//		if no parent-style	//			get parent-style from parent-category	//		derive (spawn) a new style from parent-style	//	if ( pParseBlock->mOverride			&	(	STYLE_OverrideFont				|	STYLE_OverrideSize				|	STYLE_OverrideFace				|	STYLE_OverrideColor				)			)	{		if ( NULL == pParentStyle )			pParentStyle = pParentCategory->getStylePtr();		pNewStyle = newStyle( pParseBlock, pParentStyle );	}		//	//	if category-override items were specified	//		if new style created	//			derive (spawn) a new category from parent-category using new style	//		else	//			derive (spawn) a new category from parent-category	//		set active-category to new category	//		set active-style to null	//	else	//		set active-category to parent-category	//		if new style created	//			set active-style to new style	//		else	//			set active-style to parent-style (which may be null)	//	if ( (pParseBlock->mOverride			&	( CATEGORY_OverrideRangeBefore				|  CATEGORY_OverrideRangeAfter				|  CATEGORY_OverridePriority				))			||			DIRECT_Default == pParseBlock->nCommand			)	{		if ( DIRECT_Default == pParseBlock->nCommand )		{			++vnUntitled;			::sprintf( pParseBlock->sNameCategory, "--Untitled--%d", vnUntitled );			if ( NULL == pNewStyle )				pNewStyle = pParentStyle;		}		pNewCategory = newCategory( pParseBlock, pParentCategory, pNewStyle );		if ( pNewCategory )		{			pNewCategory->addRef();			if ( vpCategoryActive )				vpCategoryActive->release();			vpCategoryActive = pNewCategory;			vnCategoryActiveID = pNewCategory->getIdent();			if ( vpActiveStyle )				vpActiveStyle->release();			vpActiveStyle = NULL;			vnActiveStyleID = 0;			result = YES;		}	}	else	{		pParentCategory->addRef();		if ( vpCategoryActive )			vpCategoryActive->release();		vpCategoryActive = pParentCategory;		vnCategoryActiveID = pParentCategory->getIdent();				if ( NULL == pNewStyle )			pNewStyle = pParentStyle;		if ( pNewStyle )		{			pNewStyle->addRef();			vnActiveStyleID = pNewStyle->getIdent();		}		else		{			vnActiveStyleID = 0;		}		if ( vpActiveStyle )			vpActiveStyle->release();		vpActiveStyle = pNewStyle;		result = YES;	}			return result;}/*---------------------------------------------------------------------+\ *  NAME:	buildCategory - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	08-Feb-1996\+---------------------------------------------------------------------*/RCategoryPtr		RemindParse::buildCategory		(		TBlockDataPtr	pParseBlock,		RCategoryPtr	pDefaultCategory		){	RCategoryPtr	pNewCategory = NULL;	RCategoryPtr	pParentCategory = NULL;	RStylePtr		pStyle = NULL;		//	// first get the parent category	//	if ( pParseBlock->sParentCategory[0] )	{		ZCategoryID	idParent;				idParent = vpCategoryMgr->findNamedCategory( pParseBlock->sParentCategory );		pParentCategory = (RCategoryPtr)vpCategoryMgr->getCategoryFromID( idParent );	}	else	{		pParentCategory = pDefaultCategory;	}		//	//	get the style that this category is to use	//	if ( pParseBlock->mOverride			&	(	STYLE_OverrideFont				|	STYLE_OverrideSize				|	STYLE_OverrideFace				|	STYLE_OverrideColor				)			)	{		RStylePtr	pParentStyle;				if ( pParseBlock->sParentStyle[0] )		{			ZStyleID	idStyle;						idStyle = vpStyleMgr->findNamedStyle( pParseBlock->sParentStyle );			pParentStyle = DYNAMIC_CAST( RStylePtr, vpStyleMgr->getStyleFromID( idStyle ) );		}		else		{			pParentStyle = pParentCategory->getStylePtr();		}		pStyle = newStyle( pParseBlock, pParentStyle );		XP_Assert( pStyle );		pParseBlock->mOverride |= CATEGORY_OverrideStyle;	}	else if ( pParseBlock->sParentStyle[0] )	{		ZStyleID	idStyle;					pParseBlock->mOverride |= CATEGORY_OverrideStyle;		idStyle = vpStyleMgr->findNamedStyle( pParseBlock->sParentStyle );		pStyle = DYNAMIC_CAST( RStylePtr, vpStyleMgr->getStyleFromID( idStyle ) );	}	else	{		pStyle = NULL;	}		pNewCategory = newCategory( pParseBlock, pParentCategory, pStyle );		return pNewCategory;}/*---------------------------------------------------------------------+\ *  NAME:	newCategory - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	11-Apr-1996\+---------------------------------------------------------------------*/RCategoryPtr		RemindParse::newCategory		(		TBlockDataPtr	pParseBlock,		RCategoryPtr	pParentCategory,		RStylePtr		pStyle		){	RCategoryPtr	pNewCategory = NULL;	ZStyleID		idStyle = 0;	RCategoryInfo	info;	int				mOverride = pParseBlock->mOverride;		if ( pParseBlock->sNameCategory[0] )	{		ZCategoryID	ident;				ident = vpCategoryMgr->findNamedCategory( pParseBlock->sNameCategory );		if ( ident )		{			return (RCategoryPtr)vpCategoryMgr->getCategoryFromID( ident );		}	}	if ( NULL == pStyle )	{		pStyle = pParentCategory->getStylePtr();		if ( pStyle )			idStyle = pStyle->getIdent();		else			idStyle = 0;		mOverride &= ~CATEGORY_OverrideStyle;	}	else	{		idStyle = pStyle->getIdent();		mOverride |= CATEGORY_OverrideStyle;	}		info.range.nBefore = pParseBlock->nBefore;	info.range.nAfter = pParseBlock->nAfter;	info.nStyleID = idStyle;	info.nPriority = (Byte)pParseBlock->nPriority;	pNewCategory = pParentCategory->spawn( &info, mOverride, 											pParseBlock->sNameCategory );	XP_Assert( pNewCategory );	if ( pNewCategory )	{		ZCategoryID	ident;				ident = vpCategoryMgr->addCategory( pNewCategory );		if ( 0 == ident )	// name already exists		{			pNewCategory->addRef();			pNewCategory->release();			pNewCategory = NULL;		}		else if ( ident < 0 )		{			if ( ident != pNewCategory->getIdent() )	// a duplicate style exists			{				pNewCategory->addRef();				pNewCategory->release();				pNewCategory = DYNAMIC_CAST( RCategoryPtr, vpCategoryMgr->getCategoryFromID( ident ) );			}		}	}		return pNewCategory;}/*---------------------------------------------------------------------+\ *  NAME:	buildStyle - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	05-Feb-1996\+---------------------------------------------------------------------*/RStylePtr		RemindParse::buildStyle		(		TBlockDataPtr	pParseBlock,		RStylePtr		pDefaultStyle		){	RStylePtr	pNewStyle;	RStylePtr	pParentStyle;	if ( pParseBlock->sParentStyle[0] )	{		ZStyleID	idParent;				idParent = vpStyleMgr->findNamedStyle( pParseBlock->sParentStyle );		pParentStyle = (RStylePtr)vpStyleMgr->getStyleFromID( idParent );	}	else	{		pParentStyle = pDefaultStyle;	}		pNewStyle = newStyle( pParseBlock, pParentStyle );	XP_Assert( pNewStyle );	return pNewStyle;}/*---------------------------------------------------------------------+\ *  NAME:	newStyle - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	11-Apr-1996\+---------------------------------------------------------------------*/RStylePtr		RemindParse::newStyle		(		TBlockDataPtr	pParseBlock,		RStylePtr		pParentStyle		){	RStyleInfo	styleInfo;	RStylePtr	pNewStyle;		if ( pParseBlock->sNameStyle[0] )	{		ZStyleID	ident;				ident = vpStyleMgr->findNamedStyle( pParseBlock->sNameStyle );		if ( ident )		{			return (RStylePtr)vpStyleMgr->getStyleFromID( ident );		}	}	if ( pParseBlock->sFontName[0] )	{		XPFontPtr	pFontServer;				pFontServer = XPFont::getFontServer();		styleInfo.font.ident = pFontServer->getFontIDFromName( pParseBlock->sFontName);	}	styleInfo.font.size = (Byte)pParseBlock->nFontSize;	styleInfo.font.face = (Byte)pParseBlock->mFontFace;	styleInfo.nColor = (Byte)pParseBlock->nFontColor;		pNewStyle = pParentStyle->spawn( &styleInfo, pParseBlock->mOverride, 									pParseBlock->sNameStyle );	XP_Assert( pNewStyle );	if ( pNewStyle )	{		ZStyleID	ident;				ident = vpStyleMgr->addStyle( pNewStyle );		if ( 0 == ident )	// name already exists		{			pNewStyle->forceRelease();			pNewStyle = NULL;		}		else if ( ident < 0 )		{			if ( ident != pNewStyle->getIdent() )	// a duplicate style exists			{				pNewStyle->forceRelease();				pNewStyle = DYNAMIC_CAST( RStylePtr, vpStyleMgr->getStyleFromID( ident ) );			}		}	}	return pNewStyle;}/*=====================================================================+\||	 private member functions											|\+=====================================================================*/#if 0#pragma mark ____private____#endif/*=====================================================================+\||																		|||	 Overrides															|||																		|\+=====================================================================*/#if 0#pragma mark ________Overrides________#endif/*---------------------------------------------------------------------+\ *  NAME:	someFunction - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	dd-mmm-1996\+---------------------------------------------------------------------*/