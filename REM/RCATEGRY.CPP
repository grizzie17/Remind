/*---------------------------------------------------------------------+\|																		||				Copyright 1986 .. 1997 Grizzly Software					||					a division of Bear Consulting Group					||						  All Rights Reserved							||																		||	This software-file/document, in whole or in part, including			||	the structures and the procedures described herein, may not			||	be provided or otherwise made available without prior written		||	authorization.  In case of authorized or unauthorized				||	publication or duplication, copyright is claimed.					||																		|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\||	rcategry.cpp  --  brief description of what rcategry.cpp is for||	Purpose:|	Author and Date:	J.Griswold			23-Oct-1995|| optional topics (delete if not used)|	Usage:|	Restrictions/Warnings:|	Algorithms/Formats:|	References:|	Notes:|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\||	Revision History:|	23-Oct-1995			J.Griswold		Initial Revision|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\|																		||	Include Files														||																		|\+---------------------------------------------------------------------*///#include "stdafx.h"		// must be first include for MFC#include "beardefs.h"#include "bcrtti.h"#include "strform.h"#include "xpassert.h"#include "zstylmgr.h"#include "rcategry.h"/*---------------------------------------------------------------------+\|																		||	Local defines / constants											||																		|\+---------------------------------------------------------------------*/#define INHERITED	ZCategory/*---------------------------------------------------------------------+\|																		||	Local Type Definitions												||																		|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\|																		||	Private Global Variables											||																		|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\|																		||	Public Global Variables												||																		|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\|																		||	External Variables													||																		|\+---------------------------------------------------------------------*//*=====================================================================+\||																		|||	 Code																|||																		|\+=====================================================================*/#if 0#pragma mark ____functions____#endif/*---------------------------------------------------------------------+\ *  NAME:	rcategory_getRawSaveString - generate a string to save to file *  DESCRIPTION:		It should be noted that the style associated with a category		is not saved by this function. *  AUTHOR: J.Griswold			DATE:	12-Mar-1997\+---------------------------------------------------------------------*/int		rcategory_getRawSaveString		(							// RTN:	number of characters generated		CharPtr			sOutString,	// OUT:	generated string		int				nMaxString,	// IN:	maximum string length available		RCategoryPtr	pCategory,	// IN:	category		int				mOverride	// IN:	override mask		){	CharPtr			start = sOutString;	CharPtr			s = sOutString;	int				n;	RCategoryInfo	info;		UNREFERENCED_PARAMETER( nMaxString );		pCategory->getData( &info );		if ( mOverride & CATEGORY_OverridePending )	{		::strcpy( s++, "," );		n = ::strFormat_decimal( s, info.range.nBefore );		s += n;		if ( mOverride & CATEGORY_OverrideRangeAfter )		{			::strcpy( s++, ":" );			n = ::strFormat_decimal( s, info.range.nAfter );			s += n;		}	}		if ( mOverride & CATEGORY_OverridePriority )	{		::strcpy( s++, "," );		::strcpy( s, "priority=" );		s += ::strlen( s );		n = ::strFormat_decimal( s, info.nPriority );		s += n;	}		// NOTE: the style information is NOT saved from this function		if ( start < s )		*start = '%';		return s - start;}#if 0#pragma mark ____class____#endif/*---------------------------------------------------------------------+\ *  NAME:	RCategory - constructor *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	23-Oct-1995\+---------------------------------------------------------------------*/RCategory::RCategory		(		void		)		: INHERITED(){	vRange.nBefore = 5;	vRange.nAfter = 0;	vnStyleID = 0;	vnPriority = 0;	vmParamOverride = 0;}/*---------------------------------------------------------------------+\ *  NAME:	RCategory - copy constructor *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	24-Oct-1995\+---------------------------------------------------------------------*/RCategory::RCategory		(		const RCategoryRef	a		)		: INHERITED( a ){	vnRefCount = (-1);	// no references		vRange = a.vRange;	vnStyleID = 0;	vnPriority = a.vnPriority;	setStyleID( a.vnStyleID );	vmParamOverride = 0;}/*---------------------------------------------------------------------+\ *  NAME:	RCategory - constructor *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	17-Jan-1996\+---------------------------------------------------------------------*/RCategory::RCategory		(		const RCategoryInfoPtr	pInfo		)		: INHERITED(){	vnStyleID = 0;	setData( pInfo );	vmParamOverride = 0;}/*---------------------------------------------------------------------+\ *  NAME:	~RCategory - destructor *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	23-Oct-1995\+---------------------------------------------------------------------*/RCategory::~RCategory		(		void		){	if ( vnStyleID )	{		setStyleID( 0 );	}}/*=====================================================================+\||	 public member functions											|\+=====================================================================*/#if 0#pragma mark ____public____#endif/*---------------------------------------------------------------------+\ *  NAME:	setData - *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	17-Jan-1996\+---------------------------------------------------------------------*/void	RCategory::setData		(		const RCategoryInfoPtr	pInfo		){	setPendingRange( pInfo->range.nBefore, pInfo->range.nAfter );	setPriority( pInfo->nPriority );	setStyleID( pInfo->nStyleID );	vmParamOverride = 0;}/*---------------------------------------------------------------------+\ *  NAME:	getData - *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	17-Jan-1996\+---------------------------------------------------------------------*/void	RCategory::getData		(		RCategoryInfoPtr	pInfo		){	pInfo->range.nBefore = vRange.nBefore;	pInfo->range.nAfter = vRange.nAfter;	pInfo->nStyleID = vnStyleID;	pInfo->nPriority = vnPriority;}/*---------------------------------------------------------------------+\ *  NAME:	getOverrideMask - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	18-Jan-1996\+---------------------------------------------------------------------*/Byte	RCategory::getOverrideMask		(		void		) const{	return vmParamOverride;}/*---------------------------------------------------------------------+\ *  NAME:	spawn - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	18-Jan-1996\+---------------------------------------------------------------------*/RCategoryPtr		RCategory::spawn		(		const RCategoryInfoPtr	pInfo,		int						mOverride,		CharPtr					sName		){	RCategoryPtr	pCategory;	RCategoryInfo	info;		getData( &info );		if ( 0 != (mOverride & CATEGORY_OverridePending) )	{		if ( CATEGORY_OverridePending				== ( mOverride & CATEGORY_OverridePending ) )			info.range = pInfo->range;		else if ( 0 != (mOverride & CATEGORY_OverrideRangeBefore) )			info.range.nBefore = pInfo->range.nBefore;		else			info.range.nAfter = pInfo->range.nAfter;	}		if ( 0 != (mOverride & CATEGORY_OverridePriority) )		info.nPriority = pInfo->nPriority;		if ( 0 != (mOverride & CATEGORY_OverrideStyle) )		info.nStyleID = pInfo->nStyleID;		pCategory = new RCategory( &info );	XP_Assert( pCategory );	if ( pCategory )	{		pCategory->setName( sName );		pCategory->vmParamOverride = mOverride;		pCategory->setParentCategory( *this );	}		return pCategory;}/*---------------------------------------------------------------------+\ *  NAME:	setStyleID - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	24-Oct-1995\+---------------------------------------------------------------------*/void	RCategory::setStyleID		(		ZStyleID	nIdent		){	ZStyleManagerPtr	pMgr;		pMgr = ZStyleManager::getStyleManager();	XP_Assert( pMgr );		if ( nIdent )		pMgr->addRefID( nIdent );		if ( vnStyleID )		pMgr->releaseID( vnStyleID );		vnStyleID = nIdent;}/*---------------------------------------------------------------------+\ *  NAME:	getStyleID - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	03-Apr-1996\+---------------------------------------------------------------------*/ZStyleID		RCategory::getStyleID		(		void		) const{	ZStyleID	nStyle = 0;		if ( 0 == vnStyleID )	{		RCategoryPtr	pParent;				pParent = (RCategoryPtr)getParentPtr();		if ( pParent )			nStyle = pParent->getStyleID();	}	else	{		nStyle = vnStyleID;	}	return nStyle;}/*---------------------------------------------------------------------+\ *  NAME:	getStylePtr - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	06-Sep-1995\+---------------------------------------------------------------------*/RStylePtr		RCategory::getStylePtr		(		void		) const{	RStylePtr	pStyle = NULL;		if ( 0 == vnStyleID )	{		RCategoryPtr	pParent;				pParent = (RCategoryPtr)getParentPtr();		if ( pParent )			pStyle = pParent->getStylePtr();	}	else	{		ZStyleManagerPtr	pMgr;		pMgr = ZStyleManager::getStyleManager();		XP_Assert( pMgr );		if ( pMgr )		{			pStyle = (RStylePtr)pMgr->getStyleFromID( vnStyleID );			XP_Assert( pStyle );		}	}	return pStyle;}/*---------------------------------------------------------------------+\ *  NAME:	setPendingRange - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	24-Oct-1995\+---------------------------------------------------------------------*/void	RCategory::setPendingRange		(		short	nBefore,		short	nAfter		){	vRange.nBefore = nBefore;	vRange.nAfter = nAfter;}/*---------------------------------------------------------------------+\ *  NAME:	getPendingRange - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	11-Apr-1996\+---------------------------------------------------------------------*/void	RCategory::getPendingRange		(		ShortPtr	pBefore,		ShortPtr	pAfter		){	*pBefore = vRange.nBefore;	*pAfter = vRange.nAfter;}/*---------------------------------------------------------------------+\ *  NAME:	setPriority - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	24-Oct-1995\+---------------------------------------------------------------------*/void	RCategory::setPriority		(		int		nPriority		){	vnPriority = nPriority;}/*=====================================================================+\||	 protected member functions											|\+=====================================================================*/#if 0#pragma mark ____protected____#endif#if 0/*---------------------------------------------------------------------+\ *  NAME:	 privatePendingString - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	17-Sep-1995\+---------------------------------------------------------------------*/static int		privatePendingString		(		CharPtr			string,		RPendingRange*	pRange		){	CharPtr	start;	int		n;		start = string;	::strcpy( string, "%" );	++string;	n = ::strFormat_decimal( string, (long) pRange->nBefore );	string += n;	if ( 0 < pRange->nAfter )	{		::strcpy( string, ":" );		++string;		n = ::strFormat_decimal( string, (long) pRange->nAfter );		string += n;	}		return string - start;}#endif/*=====================================================================+\||	 private member functions											|\+=====================================================================*/#if 0#pragma mark ____private____#endif/*=====================================================================+\||																		|||	 Overrides															|||																		|\+=====================================================================*/#if 0#pragma mark ________Overrides________#endif/*---------------------------------------------------------------------+\ *  NAME:	noMoreRefs - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	24-Oct-1995\+---------------------------------------------------------------------*/void	RCategory::noMoreRefs		(		void		){	if ( vnStyleID )		setStyleID( 0 );	INHERITED::noMoreRefs();}/*---------------------------------------------------------------------+\ *  NAME:	compare - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	26-Oct-1995\+---------------------------------------------------------------------*/Bool	RCategory::compare		(		const VCatalogItemRef	zc		) const{	Bool	result = NO;		try	{		const RCategoryRef	zs = DYNAMIC_CAST( RCategoryRef, zc );				do // sequence		{			result = INHERITED::compare( zc );			if ( ! result )				break;						result = NO;						if ( vnPriority != zs.vnPriority )				break;						if ( vnStyleID != zs.vnStyleID )				break;						if ( vRange.nBefore != zs.vRange.nBefore					||	vRange.nAfter != zs.vRange.nAfter )				break;							result = YES;				} while ( 0 ); // end sequence	}	catch ( bad_cast )	{		result = NO;	}		return result;}/*---------------------------------------------------------------------+\ *  NAME:	someFunction - brief statement *  DESCRIPTION: *  AUTHOR: J.Griswold			DATE:	dd-mmm-1995\+---------------------------------------------------------------------*/