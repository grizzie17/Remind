/*---------------------------------------------------------------------+\|																		||				Copyright 1986 .. 1997 Grizzly Software					||					a division of Bear Consulting Group					||						  All Rights Reserved							||																		||	This software-file/document, in whole or in part, including			||	the structures and the procedures described herein, may not			||	be provided or otherwise made available without prior written		||	authorization.  In case of authorized or unauthorized				||	publication or duplication, copyright is claimed.					||																		|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\||	datepars.cpp  --  date parsing routines||	Purpose:|	Author and Date:	J.Griswold			09-Aug-1983|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\||	Revision History:|	09-Jun-1988			J.Griswold		Port to Macintosh.			09-Aug-1983			J.Griswold		Initial revision|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\|																		||	Include Files														||																		|\+---------------------------------------------------------------------*///#include "stdafx.h"		// must be first include for MFC#include "bearstr.h"#include "local.h"#include "token.h"#include "tokencnv.h"#include "julian.h"#include "dkeyword.h"#include "rstring.h"#include "datevalu.h"#include "datepars.h"/*---------------------------------------------------------------------+\|																		||	Local defines / constants											||																		|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\|																		||	Local type definitions												||																		|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\|																		||	Private Global variables											||																		|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\|																		||	Public Global variables												||																		|\+---------------------------------------------------------------------*//*---------------------------------------------------------------------+\|																		||	External variables													||																		|\+---------------------------------------------------------------------*//*=====================================================================+\||																		|||	 Code																|||																		|\+=====================================================================*//*---------------------------------------------------------------------+\ *  NAME:	 parse_weekday - brief statement *  DESCRIPTION:		parse the character string weekday name			    sunday		    monday		    tuesday		    wednesday		    thursday		    friday		    saturday		The actual syntax is:   [ {even|odd} : ] weekdayname *  AUTHOR: J.Griswold		DATE:	03-Nov-1993\+---------------------------------------------------------------------*/int		parse_weekday		(		int			*pWeekNum,		int			*pWeekDay,		char		*string		){	char	*start;	int		n,j;	int		weeknum;    char	symbol[16];	start = string;    do	/* sequence */    {		n = tokenCnv_symbol( symbol, string, sizeof( symbol ) );		if ( n == 0 )		    break;		string += n;				weeknum = 0;		j = dkeyword_findEvenOdd( symbol );		if ( j != 0 )		{			weeknum = j;			string += n;			string += tok_blank( string );			if ( *string++ != ':' )			{				string = start;				break;		/* sorry bad syntax */			}						string += tok_blank( string );			n = tokenCnv_symbol( symbol, string, sizeof( symbol ) );			if ( n == 0 )			{				string = start;				break;		/* sorry still bad syntax */			}			string += n;		}			j = dkeyword_findWeekday( symbol );		if (j == 0)		{			string = start;			break;		}		*pWeekNum = weeknum;		*pWeekDay = j;	    } while ( 0 );	/* end sequence */    return string - start;}/*---------------------------------------------------------------------+\ *  NAME:	 parse_moonPhase - brief statement *  DESCRIPTION:		This routine parses a date of the format				    full moon		    new moon *  AUTHOR: J.Griswold		DATE:	03-Nov-1993\+---------------------------------------------------------------------*/int		parse_moonPhase		(		int		*pMoonPhase,		char	*string		){	char	*start;    int		i,n;    int		moon;    int		state;    char	token[16];	start = string;	state = 1;		/* start */	while ( state )	{		switch ( state )		{		case 1:		/* start */					moon = 0;			n = tokenCnv_symbol( token, string, sizeof( token ) );			if ( n == 0 )			{				state = 4;	/* failure */				break;			}						i = kwdlist_match( gMoonKwds, token );			if ( i == 0 )			{				state = 4;				break;			}						if ( i == 1  ||  i == 3 )	/* new or full */				state = 3;			else				state = 2;						moon = i - 1;			string += n;			string += tok_blank( string );			break;				case 2:		/* "quarter" */					n = tokenCnv_symbol( token, string, sizeof( token ) );			if ( n == 0 )			{				state = 4;	/* failure */				break;			}						if ( string_icompareCount( token, "quarter", n ) != 0 )			{				state = 4;	/* failure */				break;			}						state = 3;			string += n;			string += tok_blank( string );			break;				case 3:		/* "moon" */					n = tokenCnv_symbol( token, string, sizeof( token ) );			if ( n == 0 )			{				state = 4;	/* failure */				break;			}						if ( string_icompareCount( token, "moon", n ) != 0 )			{				state = 4;	/* failure */				break;			}						state = 0;			string += n;			*pMoonPhase = moon;			break;				case 4:		/* failure */		default:			string = start;			moon = 0;			state = 0;			break;		}	}	return string - start;}/*---------------------------------------------------------------------+\ *  NAME:	 parse_monthSymbol *  DESCRIPTION:		This routine parses a month identifier into a month number	 *  AUTHOR: J.Griswold		DATE:	03-Nov-1993\+---------------------------------------------------------------------*/static int parse_monthSymbol		(					/* RTN: returns the number of characters parsed */		long	*pMonth,	/* OUT:	numeric month */		long	*pCycle,	/* OUT:	monthly cycle */		char	*string		){	char	*start;	long	mm;	long	nCycle;	int		n;	char	token[16];		start = string;	mm = 0;	nCycle = 0;	n = tokenCnv_symbol( token, string, sizeof( token ) );	if ( n )	{	    string += n;	    mm = dkeyword_findMonth( token );	/* month name specified ? */	    if ( mm == 0 )	    {	    	mm = dkeyword_findEvenOdd( token );	/* how about: even or odd ? */	    	if ( mm )	    	{	    		nCycle = 2;	    	}	    	else	    	{	    		nCycle = dkeyword_findMonthCycle( token );	    		if ( nCycle )	    		{	    			string += tok_blank( string );	    			if ( '(' == *string )	    			{	    				++string;	    				string += tok_blank( string );	    				n = tokenCnv_decimal( &mm, string );	    				if ( n )	    				{	    					if ( mm <= nCycle )	    					{	    						string += n;	    						string += tok_blank( string );	    						if ( ')' == *string )	    							++string;	    					}	    					else	    					{	    						string = start;	    					}	    				}	    				else	    				{	    					string = start;	    				}	    			}	    			else	    			{	    				string = start;	    			}	    		}	    		else	    		{		    		string = start;	    		}	    	}	    }	}	*pMonth = mm;	*pCycle = nCycle;		return string - start;}/*---------------------------------------------------------------------+\ *  NAME:	 parse_monthWild *  DESCRIPTION:		This routine parses a month identifier or wild-card				The month may be specified by either:		- numeric month		- month name (abbreviations allowed)		- wild-card (*)	 *  AUTHOR: J.Griswold		DATE:	03-Nov-1993\+---------------------------------------------------------------------*/static int parse_monthWild		(		long	*pMonth,		long	*pCycle,		char	*string		){	char	*start;	long	mm;	long	nCycle;	int		n;		start = string;	mm = 0;	nCycle = 0;		n = parse_monthSymbol( &mm, &nCycle, string );	if ( n )	{	    string += n;	}	else	{	    if ( *string == '*' )	/* wildcard */	    {			++string;			mm = 0;	    }	    else	    {			n = tokenCnv_unsigned( (unsigned long *)&mm, string );			if ( n )			{			    string += n;			    if ( mm <= 0  ||  12 < mm )			    {			    	mm = 0;			    	string = start;	/* bad month number */				}			}	    }	}	*pMonth = mm;	*pCycle = nCycle;		return string - start;}/*---------------------------------------------------------------------+\ *  NAME:	 parse_yearWild *  DESCRIPTION:		This routine parses a year identifier or wild-card				The year may be specified by either:		- numeric year		- abbreviated year (without the century {eg. 95 for 1995})		- wild-card (*)				When a numeric year is specified an anniversary frequency may		be specified by prefixing the number of years with an atsign (@).		(e.g., 1945@5 states that the message is for the year 1945 but will		reoccur every 5 years after).	 *  AUTHOR: J.Griswold		DATE:	03-Nov-1993\+---------------------------------------------------------------------*/static int parse_yearWild		(		long	*pYear,		long	*pAnniv,		char	*string		){	char	*start;	long	yy;	long	ann;	int		n;		start = string;	yy = 0;	ann = 0;	n = tokenCnv_unsigned( (ULong *)&yy, string );	if ( n )	{	    string += n;	    if ( yy <= 0 )	    {	    	string = start;		/* bad year */	    }		else		{			CharPtr	temp;						if ( yy < 100 )				yy += dateValue_century();						temp = string;			string += tok_blank( string );			if ( '@' == *string )	// anniversary			{				++string;				string += tok_blank( string );				n = tokenCnv_unsigned( (ULong *)&ann, string );				if ( n )					string += n;				else					string = temp;	// anniv: bad format			}		}	}	else	{	    if ( *string == '*' )	    {			++string;			yy = 0;	    }	    else	    {	    	string = start;	/* bad syntax */	    }	}	*pYear = yy;	*pAnniv = ann;	return string - start;}/*---------------------------------------------------------------------+\ *  NAME:	 parse_ddmmmyyyy - brief statement *  DESCRIPTION:		This routine parses a date with the format			    dd-mmm[-yyyy]			    where:				dd		is the numeric day of the month						(negative day indicates the day from						the end of the month)						mmm		is the character name, numeric, or						wild card value of the month.						yyyy	is the numeric or wild card (*) value						of the year.  (if the century is absent						it is added). *  AUTHOR: J.Griswold		DATE:	03-Nov-1993\+---------------------------------------------------------------------*/int		parse_ddmmmyyyy		(		int		*pDay,		//	OUT:		int		*pMonth,	//	OUT:		int		*pCycle,	//	OUT:		int		*pYear,		//	OUT:		int		*pAnniv,	//	OUT:		char	*string		){	char	*start;	int		wild;    int		n;    long	dd,mm,yy,anniv;    long	nCycle;	start = string;	wild = NO;    do	/* sequence */    {		/*		//	day of month		*/		n = tokenCnv_decimal( &dd, string );		if ( n == 0 )		    break;		/* bad syntax: must begin with number */		string += n;		if ( *string++ != '-' )		{			string = start;			break;		/* bad syntax */		}		/*		//	month of year		*/		mm = 0;		n = parse_monthWild( &mm, &nCycle, string );		if ( n == 0 )		{			string = start;			break;		}	    string += n;	    if ( mm < 1 )	    	wild = YES;		/*		//	year (optional)		*/		if ( *string == '-' )		{			++string;			yy = 0;			n = parse_yearWild( &yy, &anniv, string );			if ( n == 0 )			{				string = start;				break;			}			string += n;						if ( yy == 0 )				wild = YES;		}		else		{			yy = 0;			wild = YES;		}		*pDay = dd;		*pMonth = mm;		*pCycle = nCycle;		*pYear = yy;		*pAnniv = anniv;    } while ( 0 );	/* end sequence */    return string - start;}/*---------------------------------------------------------------------+\ *  NAME:	 parse_mmmddyyyy *  DESCRIPTION:		This routine parses a date of the form:			    mmm dd [, yyyy]			    where:					mmm		is the name of the month				dd		is the numeric date				yyyy	is the optional numeric year. *  AUTHOR: J.Griswold		DATE:	03-Nov-1993\+---------------------------------------------------------------------*/int		parse_mmmddyyyy		(		int		*pDay,		//	OUT:		int		*pMonth,	//	OUT:		int		*pCycle,	//	OUT:		int		*pYear,		//	OUT:		int		*pAnniv,	//	OUT:		char	*string		){	char	*start;	int		wild;    int		n;    long	dd,mm,yy,anniv;    long	nCycle;	start = string;	wild = NO;    do	/* sequence */    {		n = parse_monthSymbol( &mm, &nCycle, string );	/* get month name */		if ( n == 0 )		    break;			string += n;		if ( mm < 1 )			wild = YES;				if ( *string == '.' )			/* get optional period */		    ++string;			string += tok_blank( string );			n = tokenCnv_decimal( &dd, string );		/* get date */		if ( n == 0 )		{			string = start;		    break;		}		string += n;			if ( *string == ',' )		{		    ++string;		    string += tok_blank( string );			n = parse_yearWild( &yy, &anniv, string );			if ( n == 0 )			{				string = start;				break;			}						string += n;			if ( yy == 0 )				wild = YES;		}		else		{			wild = YES;			yy = 0;		}				*pDay = dd;		*pMonth = mm;		*pCycle = nCycle;		*pYear = yy;		*pAnniv = anniv;    } while ( 0 );	/* end sequence */    return string - start;}/*---------------------------------------------------------------------+\ *  NAME:	 parse_mdy *  DESCRIPTION:		This routine parses a date of the form:			    mm/dd/yy			    where:					mm	is the numeric or named month				dd	is the numeric date				yy	is the numeric year *  AUTHOR: J.Griswold		DATE:	03-Nov-1993\+---------------------------------------------------------------------*/int		parse_mdy		(		int		*pDay,		//	OUT:		int		*pMonth,	//	OUT:		int		*pCycle,	//	OUT:		int		*pYear,		//	OUT:		int		*pAnniv,	//	OUT:		char	*string		){	char	*start;	int		wild;    int		n;    long	dd,mm,yy,anniv;    long	nCycle;	start = string;	wild = NO;    do	/* sequence */    {		n = parse_monthWild( &mm, &nCycle, string );		if ( n == 0 )		    break;		string += n;				string += tok_blank( string );		if ( *string++ != '/' )		{			string = start;		    break;		}				string += tok_blank( string );		n = tokenCnv_decimal( &dd, string );		if ( n == 0 )		{			string = start;		    break;		}		string += n;				string += tok_blank( string );				if ( *string != '/' )		{			wild = YES;			yy = 0;		}		else		{			++string;			string += tok_blank( string );			yy = 0;			n = parse_yearWild( &yy, &anniv, string );			if ( n == 0 )			{				string = start;				break;			}			string += n;						if ( yy == 0 )				wild = YES;		}			*pDay = dd;		*pMonth = mm;		*pCycle = nCycle;		*pYear = yy;		*pAnniv = anniv;    } while ( 0 );	/* end sequence */    return string - start;}/*---------------------------------------------------------------------+\ *  NAME:	 parse_nnwwwmmmyyyy *  DESCRIPTION:	    This routine converts an ascii string calendar date of	    the form:			nn:www-mmm-yyyy			where:				nn		is the numeric week-number of the month			www		is the character weekday name			mmm		is the numeric, character, or wild card value					of the month.			yyyy	is the numeric or wild card value of the year.	 *  AUTHOR: J.Griswold		DATE:	03-Nov-1993\+---------------------------------------------------------------------*/int		parse_nnwwwmmmyyyy		(		int		*pWeekNum,	//	OUT:		int		*pWeekDay,	//	OUT:		int		*pMonth,	//	OUT:		int		*pCycle,	//	OUT:		int		*pYear,		//	OUT:		int		*pAnniv,	//	OUT:		char	*string		){	char	*start;    int		n;    long	dd, ww, mm, yy, anniv;    long	nCycle;    char	token[16];	start = string;    do	/* sequence */    {    	/*    	//	get week number    	*/		n = tokenCnv_decimal( &dd, string );		if ( n == 0 )		    break;		string += n;			if ( *string++ != ':' )		{			string = start;		    break;		}				/*		//	get weekday		*/		n = tokenCnv_symbol( token, string, sizeof( token ) );		if ( n == 0 )		{			string = start;			break;		}		ww = dkeyword_findWeekday( token );		if ( ww == 0 )		{			string = start;			break;		}		string += n;			if ( *string++ != '-' )		{			string = start;		    break;		}		/*		//	month of year		*/		mm = 0;		n = parse_monthWild( &mm, &nCycle, string );		if ( n == 0 )		{			string = start;			break;		}	    string += n;		/*		//	year (optional)		*/		if ( *string == '-' )		{			++string;			yy = 0;			n = parse_yearWild( &yy, &anniv, string );			if ( n == 0 )			{				string = start;				break;			}			string += n;		}		else		{			yy = 0;		}		*pWeekNum = dd;		*pWeekDay = ww;		*pMonth = mm;		*pCycle = nCycle;		*pYear = yy;		*pAnniv = anniv;    } while ( 0 );	/* end sequence */    return string - start;}/*---------------------------------------------------------------------+\ *  NAME:	 parse_kwdday -  *  DESCRIPTION:		parses a string of characters into a date record. *  AUTHOR: J.Griswold		DATE:	dd-mmm-1993\+---------------------------------------------------------------------*/int		parse_kwdday		(		int		*pIdent,	//	OUT:		char	*string		){	char	*start;	int		n,j;    static char	symbol[16];        start = string;    do	/* sequence */    {    	n = tokenCnv_symbol( symbol, string, sizeof( symbol ) );		if ( n == 0 )		    break;				j = dkeyword_findPaschal( symbol );		if (j == 0)		    break;		string += n;				*pIdent = j;	    } while ( 0 );	/* end sequence */    return string - start;}/*---------------------------------------------------------------------+\ *  NAME:	 dateParse_dateString -  *  DESCRIPTION:		parses a string of characters into a date record. *  AUTHOR: J.Griswold		DATE:	dd-mmm-1993\+---------------------------------------------------------------------*/int		dateParse_dateString		(						/* RTN:	number of characters in date */		MParsePtr	pDate,		/* OUT:	date */		char		*string		/* IN:	string to parse */		){	char	*start;	int		len;	int		nDay;	int		nWeekDay;	int		nWeekNum;	int		nMonth;	int		nCycle;	int		nYear;	int		nAnniv;	int		nIdent;		UNREFERENCED_PARAMETER( pDate );		start = string;	len = 0;	do /* sequence */	{		len = parse_weekday( &nWeekNum, &nWeekDay, string );		if ( len )			break;				len = parse_ddmmmyyyy( &nDay, &nMonth, &nCycle, &nYear, &nAnniv, string );		if ( len )			break;		len = parse_nnwwwmmmyyyy( &nWeekNum, &nWeekDay, &nMonth, &nCycle, &nYear, &nAnniv, string );		if ( len )			break;		len = parse_mdy(  &nDay, &nMonth, &nCycle, &nYear, &nAnniv, string );		if ( len )			break;		len = parse_mmmddyyyy(  &nDay, &nMonth, &nCycle, &nYear, &nAnniv, string );		if ( len )			break;		len = parse_moonPhase( &nIdent, string );		if ( len )			break;				len = parse_kwdday( &nIdent, string );		if ( len )			break;	} while ( 0 ); /* end sequence */		return len;}